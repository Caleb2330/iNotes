diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.cpp
index b5346f5..a257713 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.cpp
@@ -9,7 +9,7 @@ std::lock_guard<std::mutex> PropsRegistry::createLock() const {
 }
 
 void PropsRegistry::update(
-    const ShadowNode::Shared &shadowNode,
+    const std::shared_ptr<const ShadowNode> &shadowNode,
     folly::dynamic &&props) {
   const auto tag = shadowNode->getTag();
   const auto it = map_.find(tag);
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.h b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.h
index 2722a6f..b27b974 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.h
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/PropsRegistry.h
@@ -17,7 +17,7 @@ class PropsRegistry {
   std::lock_guard<std::mutex> createLock() const;
   // returns a lock you need to hold when calling any of the methods below
 
-  void update(const ShadowNode::Shared &shadowNode, folly::dynamic &&props);
+  void update(const std::shared_ptr<const ShadowNode> &shadowNode, folly::dynamic &&props);
 
   void for_each(std::function<void(
                     const ShadowNodeFamily &family,
@@ -46,7 +46,7 @@ class PropsRegistry {
   }
 
  private:
-  std::unordered_map<Tag, std::pair<ShadowNode::Shared, folly::dynamic>> map_;
+  std::unordered_map<Tag, std::pair<std::shared_ptr<const ShadowNode>, folly::dynamic>> map_;
 
   mutable std::mutex mutex_; // Protects `map_`.
 
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.cpp
index fc5050c..ca698b9 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.cpp
@@ -18,7 +18,7 @@ ReanimatedMountHook::~ReanimatedMountHook() noexcept {
 
 void ReanimatedMountHook::shadowTreeDidMount(
     RootShadowNode::Shared const &rootShadowNode,
-    double) noexcept {
+    facebook::react::HighResTimeStamp) noexcept {
   auto reaShadowNode =
       std::reinterpret_pointer_cast<ReanimatedCommitShadowNode>(
           std::const_pointer_cast<RootShadowNode>(rootShadowNode));
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.h b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.h
index 143eb87..b0c9e70 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.h
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ReanimatedMountHook.h
@@ -21,7 +21,7 @@ class ReanimatedMountHook : public UIManagerMountHook {
 
   void shadowTreeDidMount(
       RootShadowNode::Shared const &rootShadowNode,
-      double mountTime) noexcept override;
+      facebook::react::HighResTimeStamp mountTime) noexcept override;
 
  private:
   const std::shared_ptr<PropsRegistry> propsRegistry_;
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ShadowTreeCloner.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ShadowTreeCloner.cpp
index 5795b73..ea27d55 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ShadowTreeCloner.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/Fabric/ShadowTreeCloner.cpp
@@ -7,7 +7,7 @@
 
 namespace reanimated {
 
-ShadowNode::Unshared cloneShadowTreeWithNewPropsRecursive(
+std::shared_ptr<ShadowNode> cloneShadowTreeWithNewPropsRecursive(
     const ShadowNode &shadowNode,
     const ChildrenMap &childrenMap,
     const PropsMap &propsMap) {
@@ -37,7 +37,7 @@ ShadowNode::Unshared cloneShadowTreeWithNewPropsRecursive(
 
   const auto result = shadowNode.clone(
       {newProps ? newProps : ShadowNodeFragment::propsPlaceholder(),
-       std::make_shared<ShadowNode::ListOfShared>(children),
+       std::make_shared<std::vector<std::shared_ptr<const ShadowNode>>>(children),
        shadowNode.getState()});
 
   return result;
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.cpp
index 8102462..7256d2e 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.cpp
@@ -70,10 +70,10 @@ std::optional<SurfaceId> LayoutAnimationsProxy::progressLayoutAnimation(
 
   PropsParserContext propsParserContext{
       layoutAnimation.finalView->surfaceId, *contextContainer_};
-#ifdef ANDROID
-  rawProps = std::make_shared<RawProps>(folly::dynamic::merge(
-      layoutAnimation.finalView->props->rawProps, (folly::dynamic)*rawProps));
-#endif
+// #ifdef ANDROID
+  //   rawProps = std::make_shared<RawProps>(folly::dynamic::merge(
+  //       layoutAnimation.finalView->props->rawProps, (folly::dynamic)*rawProps));
+  // #endif
   auto newProps =
       getComponentDescriptorForShadowView(*layoutAnimation.finalView)
           .cloneProps(
@@ -153,7 +153,7 @@ void LayoutAnimationsProxy::parseRemoveMutations(
     if (mutation.type == ShadowViewMutation::Remove) {
       updateIndexForMutation(mutation);
       auto tag = mutation.oldChildShadowView.tag;
-      auto parentTag = mutation.parentShadowView.tag;
+      auto parentTag = mutation.parentTag;
       auto unflattenedParentTag = parentTag; // temporary
 
       std::shared_ptr<MutationNode> mutationNode;
@@ -287,8 +287,8 @@ void LayoutAnimationsProxy::handleUpdatesAndEnterings(
       }
       case ShadowViewMutation::Type::Insert: {
         updateIndexForMutation(mutation);
-        if (nodeForTag_.contains(mutation.parentShadowView.tag)) {
-          nodeForTag_[mutation.parentShadowView.tag]->applyMutationToIndices(
+        if (nodeForTag_.contains(mutation.parentTag)) {
+          nodeForTag_[mutation.parentTag]->applyMutationToIndices(
               mutation);
         }
 
@@ -297,7 +297,7 @@ void LayoutAnimationsProxy::handleUpdatesAndEnterings(
           if (layoutAnimationIt == layoutAnimations_.end()) {
             if (oldShadowViewsForReparentings.contains(tag)) {
               filteredMutations.push_back(ShadowViewMutation::InsertMutation(
-                  mutation.parentShadowView,
+                  mutation.parentTag,
                   oldShadowViewsForReparentings[tag],
                   mutation.index));
             } else {
@@ -308,7 +308,7 @@ void LayoutAnimationsProxy::handleUpdatesAndEnterings(
 
           auto oldView = *layoutAnimationIt->second.currentView;
           filteredMutations.push_back(ShadowViewMutation::InsertMutation(
-              mutation.parentShadowView, oldView, mutation.index));
+              mutation.parentTag, oldView, mutation.index));
           continue;
         }
 
@@ -328,7 +328,7 @@ void LayoutAnimationsProxy::handleUpdatesAndEnterings(
             cloneViewWithoutOpacity(mutation, propsParserContext);
 
         filteredMutations.push_back(ShadowViewMutation::UpdateMutation(
-            mutation.newChildShadowView, *newView, mutation.parentShadowView));
+            mutation.newChildShadowView, *newView, mutation.parentTag));
         break;
       }
 
@@ -556,11 +556,11 @@ void LayoutAnimationsProxy::updateIndexForMutation(
   if (mutation.index == -1) {
     return;
   }
-  if (!nodeForTag_.contains(mutation.parentShadowView.tag)) {
+  if (!nodeForTag_.contains(mutation.parentTag)) {
     return;
   }
 
-  auto parent = nodeForTag_[mutation.parentShadowView.tag];
+  auto parent = nodeForTag_[mutation.parentTag];
 
   int size = 0, prevIndex = -1, offset = 0;
 
@@ -606,7 +606,9 @@ void LayoutAnimationsProxy::createLayoutAnimation(
           ? mutation.oldChildShadowView
           : mutation.newChildShadowView);
   auto currentView = std::make_shared<ShadowView>(oldView);
-  auto parentView = std::make_shared<ShadowView>(mutation.parentShadowView);
+  ShadowView parentShadowView;
+  parentShadowView.tag = mutation.parentTag;
+  auto parentView = std::make_shared<ShadowView>(parentShadowView);
   layoutAnimations_.insert_or_assign(
       tag, LayoutAnimation{finalView, currentView, parentView, {}, count});
 }
@@ -619,7 +621,9 @@ void LayoutAnimationsProxy::startEnteringAnimation(
 #endif
   auto finalView = std::make_shared<ShadowView>(mutation.newChildShadowView);
   auto current = std::make_shared<ShadowView>(mutation.newChildShadowView);
-  auto parent = std::make_shared<ShadowView>(mutation.parentShadowView);
+  ShadowView parentShadowView;
+  parentShadowView.tag = mutation.parentTag;
+  auto parent = std::make_shared<ShadowView>(parentShadowView);
 
   auto &viewProps =
       static_cast<const ViewProps &>(*mutation.newChildShadowView.props);
@@ -786,11 +790,11 @@ void LayoutAnimationsProxy::maybeUpdateWindowDimensions(
     SurfaceId surfaceId) const {
   // This is a hacky way to obtain the window dimensions.
   // We can identify the root, by checking if its tag is equal to the surfaceId
-  if (mutation.parentShadowView.tag == surfaceId) {
-    surfaceManager.updateWindow(
-        surfaceId,
-        mutation.parentShadowView.layoutMetrics.frame.size.width,
-        mutation.parentShadowView.layoutMetrics.frame.size.height);
+  if (mutation.parentTag == surfaceId) {
+    // surfaceManager.updateWindow(
+    //     surfaceId,
+    //     mutation.parentShadowView.layoutMetrics.frame.size.width,
+    //     mutation.parentShadowView.layoutMetrics.frame.size.height);
   }
 }
 
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsUtils.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsUtils.cpp
index c8105bf..0d7b590 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsUtils.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsUtils.cpp
@@ -31,7 +31,7 @@ Rect SurfaceManager::getWindow(SurfaceId surfaceId) {
 }
 
 void Node::applyMutationToIndices(ShadowViewMutation mutation) {
-  if (tag != mutation.parentShadowView.tag) {
+  if (tag != mutation.parentTag) {
     return;
   }
 
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.cpp b/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.cpp
index 3b5f6f5..62791f0 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.cpp
@@ -34,6 +34,13 @@
 #include <iomanip>
 #include <sstream>
 #include <string>
+
+static inline std::shared_ptr<const ShadowNode> shadowNodeFromValue(
+    jsi::Runtime &rt,
+    const jsi::Value &value) {
+  auto list = shadowNodeListFromValue(rt, value);
+  return list->empty() ? nullptr : (*list)[0];
+}
 #endif // RCT_NEW_ARCH_ENABLED
 
 // Standard `__cplusplus` macro reference:
@@ -319,7 +326,7 @@ static inline std::string intColorToHex(const int val) {
 std::string NativeReanimatedModule::obtainPropFromShadowNode(
     jsi::Runtime &rt,
     const std::string &propName,
-    const ShadowNode::Shared &shadowNode) {
+    const std::shared_ptr<const ShadowNode> &shadowNode) {
   auto newestCloneOfShadowNode =
       uiManager_->getNewestCloneOfShadowNode(*shadowNode);
 
@@ -788,7 +795,7 @@ void NativeReanimatedModule::dispatchCommand(
     const jsi::Value &shadowNodeValue,
     const jsi::Value &commandNameValue,
     const jsi::Value &argsValue) {
-  ShadowNode::Shared shadowNode = shadowNodeFromValue(rt, shadowNodeValue);
+  std::shared_ptr<const ShadowNode> shadowNode = shadowNodeFromValue(rt, shadowNodeValue);
   std::string commandName = stringFromValue(rt, commandNameValue);
   folly::dynamic args = commandArgsFromValue(rt, argsValue);
   uiManager_->dispatchCommand(shadowNode, commandName, args);
diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.h b/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.h
index f44d6ff..de6cd89 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.h
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/NativeModules/NativeReanimatedModule.h
@@ -142,7 +142,7 @@ class NativeReanimatedModule : public NativeReanimatedModuleSpec {
   std::string obtainPropFromShadowNode(
       jsi::Runtime &rt,
       const std::string &propName,
-      const ShadowNode::Shared &shadowNode);
+      const std::shared_ptr<const ShadowNode> &shadowNode);
 #endif
 
   jsi::Value registerSensor(
@@ -222,7 +222,7 @@ class NativeReanimatedModule : public NativeReanimatedModuleSpec {
   // We can store surfaceId of the most recent ShadowNode as a workaround.
   SurfaceId surfaceId_ = -1;
 
-  std::vector<std::pair<ShadowNode::Shared, std::unique_ptr<jsi::Value>>>
+  std::vector<std::pair<std::shared_ptr<const ShadowNode>, std::unique_ptr<jsi::Value>>>
       operationsInBatch_; // TODO: refactor std::pair to custom struct
 
   std::shared_ptr<PropsRegistry> propsRegistry_;
diff --git a/node_modules/react-native-reanimated/android/build.gradle b/node_modules/react-native-reanimated/android/build.gradle
index 6129944..c883a0f 100644
--- a/node_modules/react-native-reanimated/android/build.gradle
+++ b/node_modules/react-native-reanimated/android/build.gradle
@@ -4,6 +4,9 @@ import org.apache.tools.ant.taskdefs.condition.Os
 import groovy.json.JsonSlurper
 import com.android.build.gradle.tasks.ExternalNativeBuildJsonTask
 
+// Fix for Windows MAX_PATH issues
+project.buildDir = file("C:\\InoteCloneBuild\\reanimated")
+
 import javax.inject.Inject
 import java.nio.file.Files
 import java.nio.file.Paths
@@ -272,6 +275,7 @@ android {
         cmake {
             version = System.getenv("CMAKE_VERSION") ?: "3.22.1"
             path "CMakeLists.txt"
+            buildStagingDirectory file("C:\\InoteCloneBuild\\reanimated_cxx")
         }
     }
     buildTypes {
diff --git a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedPackage.java b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedPackage.java
index 112f758..6d4e7db 100644
--- a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedPackage.java
+++ b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedPackage.java
@@ -69,7 +69,7 @@ public class ReanimatedPackage extends TurboReactPackage implements ReactPackage
 
   private UIManagerModule createUIManager(final ReactApplicationContext reactContext) {
     ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_START);
-    Systrace.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, "createUIManagerModule");
+    Systrace.beginSection(0L, "createUIManagerModule");
     final ReactInstanceManager reactInstanceManager = getReactInstanceManager(reactContext);
     List<ViewManager> viewManagers = reactInstanceManager.getOrCreateViewManagers(reactContext);
     int minTimeLeftInFrameForNonBatchedOperationMs = -1;
@@ -77,7 +77,7 @@ public class ReanimatedPackage extends TurboReactPackage implements ReactPackage
       return ReanimatedUIManagerFactory.create(
           reactContext, viewManagers, minTimeLeftInFrameForNonBatchedOperationMs);
     } finally {
-      Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE);
+      Systrace.endSection(0L);
       ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_END);
     }
   }
diff --git a/node_modules/react-native-reanimated/android/src/reactNativeVersionPatch/BorderRadiiDrawableUtils/latest/com/swmansion/reanimated/BorderRadiiDrawableUtils.java b/node_modules/react-native-reanimated/android/src/reactNativeVersionPatch/BorderRadiiDrawableUtils/latest/com/swmansion/reanimated/BorderRadiiDrawableUtils.java
index c850777..8af7c09 100644
--- a/node_modules/react-native-reanimated/android/src/reactNativeVersionPatch/BorderRadiiDrawableUtils/latest/com/swmansion/reanimated/BorderRadiiDrawableUtils.java
+++ b/node_modules/react-native-reanimated/android/src/reactNativeVersionPatch/BorderRadiiDrawableUtils/latest/com/swmansion/reanimated/BorderRadiiDrawableUtils.java
@@ -18,7 +18,7 @@ public class BorderRadiiDrawableUtils {
       return defaultValue;
     }
     Rect bounds = view.getBackground().getBounds();
-    return length.resolve(bounds.width(), bounds.height()).toPixelFromDIP().getHorizontal();
+    return length.resolve((float) bounds.width());
   }
 
   public static ReactNativeUtils.BorderRadii getBorderRadii(View view) {
